# DevOps Infra App

üõ†Ô∏è A complete DevOps project: a minimal Node.js + Express web application, containerized with Docker, automated with GitHub Actions, and infrastructure managed via Terraform on AWS.

---

## üì¶ Project Overview

**DevOps Infra App** is a demonstration project designed to simulate the workflow of a DevOps Engineer in a real-world environment.  
It serves as a foundation for:

- CI/CD automation  
- Deployment on AWS EC2  
- Containerization using Docker  
- Infrastructure as Code with Terraform  
- Monitoring with Prometheus + Grafana  
- Comprehensive technical documentation  

The application is a simple **Node.js + Express** server with a single endpoint (`GET /`) returning a plain text message for testing and health checks.

---

## üß∞ Technologies Used

- Node.js & Express  
- Docker  
- Git & GitHub  
- GitHub Actions (CI/CD)  
- AWS (EC2, IAM, S3)  
- Terraform  
- Prometheus + Grafana  
- Nginx, SSH, Linux  

---

## üöÄ Progress Summary

### 1. Application Setup

- Created a minimal Node.js + Express application with basic routing.  
- Initialized the project with `package.json` and installed dependencies.  
- Successfully ran the application locally (`npm start`) on port 3000.

### 2. Docker Containerization

- Built a `Dockerfile` based on `node:18-alpine` to containerize the application.  
- Explained Dockerfile steps: working directory setup, copying source code, installing dependencies, exposing port, and start command.  
- Tested container locally to ensure consistent environment.  
- Updated documentation with Docker usage instructions.

### 3. AWS CLI & IAM User Setup

- Created an IAM user in AWS with programmatic access keys.  
- Encountered initial `SignatureDoesNotMatch` errors due to invalid or expired credentials.  
- Regenerated Access Key and Secret Access Key, saved securely as CSV.  
- Configured AWS CLI locally with the new credentials and region (`eu-central-1`).
- Verified AWS CLI authentication by running:
  ```bash
  aws sts get-caller-identity
  ```

### 4. Terraform Infrastructure Provisioning

- Created Terraform configuration files to provision AWS resources:
  - An EC2 instance (`t2.micro`) with a valid AMI in `eu-central-1` region.
  - An S3 bucket with a unique name generated by the `random_id` resource.
- Addressed deprecation warnings by removing the deprecated `acl` attribute from the S3 bucket and using the `aws_s3_bucket_acl` resource.
- Solved AWS API errors related to invalid AMI IDs by updating to a region-appropriate AMI.
- Successfully applied Terraform configuration to create and manage cloud infrastructure.

### 5. EC2 Instance Management

- Connected to the EC2 instance via SSH using a previously created key pair.
- Configured AWS Security Group rules to allow SSH access from the client IP address.
- Learned that Terraform does not create key pairs automatically; had to create/upload key pairs manually in AWS console.
- Troubleshot connection issues and verified instance status via the AWS Management Console.

### 6. Docker on EC2 Instance

- Installed Docker on the EC2 instance to support container execution.
- Cloned the GitHub repository containing the project source code to the EC2 instance.
- Built the Docker image on the EC2 instance, matching the local Dockerfile to ensure consistency.
- Ran the Docker container on EC2, exposing port 3000 and confirming application availability via the public DNS.


